/* eslint-disable */
(function(h,m) { typeof exports == "object" && typeof module < "u" ? m(exports,require("axios"),require("socket.io-client")) : typeof define == "function" && define.amd ? define(["exports","axios","socket.io-client"],m) : (h = typeof globalThis < "u" ? globalThis : h || self,m(h.WavoipAPI = {},h.axios,h.io)) })(this,function(h,m,f) { "use strict"; var V = Object.defineProperty; var X = (h,m,f) => m in h ? V(h,m,{enumerable: !0,configurable: !0,writable: !0,value: f}) : h[m] = f; var l = (h,m,f) => X(h,typeof m != "symbol" ? m + "" : m,f); var b = typeof document < "u" ? document.currentScript : null; class p {constructor() { l(this,"listeners",new Map()) }emit(a,...e) { const t = this.listeners.get(a) || []; for (const s of t)s(...e) }on(a,e) { const t = this.listeners.get(a) || []; return t.push(e),this.listeners.set(a,t),() => this.off(a,e) }off(a,e) { const t = this.listeners.get(a); t && this.listeners.set(a,t.filter(s => s !== e)) }removeAllListeners(a) { return this.listeners.delete(a) }} class y extends p {constructor(e) { super(); l(this,"pc",null); l(this,"audioContext"); l(this,"audioAnalyserDeffer",{}); l(this,"muteInterval",null); l(this,"statsInterval",null); l(this,"answer",null); l(this,"peerMuted",!1); l(this,"audioAnalyser"); l(this,"status","connecting"); l(this,"stats"); this.microphone = e,this.audioContext = new AudioContext({sampleRate: 48e3,latencyHint: 0}),this.audioContext.suspend(),this.audioAnalyser = new Promise(t => { this.audioAnalyserDeffer = {resolve: t} }),this.stats = {rtt: {avg: 0,max: 0,min: 0},rx: {loss: 0,total: 0,total_bytes: 0},tx: {loss: 0,total: 0,total_bytes: 0}} } async start(e) { var s; if (!((s = this.microphone.deviceUsed) != null && s.stream)) return; const t = this.microphone.deviceUsed.stream; this.audioContext.state === "suspended" && await this.audioContext.resume(),this.pc = new RTCPeerConnection(); for (const i of t.getTracks())i.enabled = !0,this.pc.addTrack(i,t); this.pc.ontrack = i => { var u,d; const n = i.streams[0],o = this.audioContext.createMediaStreamSource(n),c = this.audioContext.createAnalyser(); c.fftSize = 256,o.connect(c),c.connect(this.audioContext.destination),(d = (u = this.audioAnalyserDeffer).resolve) == null || d.call(u,c),this.getStats(this.pc),this.muteInterval = setInterval(() => this.checkForMute(c),1e3),this.statsInterval = setInterval(() => this.getStats(this.pc),5e3) },this.pc.onconnectionstatechange = () => { var i,n,o,c,u; ((i = this.pc) == null ? void 0 : i.connectionState) === "connecting" && this.setStatus("connecting"),(((n = this.pc) == null ? void 0 : n.connectionState) === "disconnected" || ((o = this.pc) == null ? void 0 : o.connectionState) === "closed") && this.setStatus("disconnected"),((c = this.pc) == null ? void 0 : c.connectionState) === "closed" && this.audioContext.suspend(),((u = this.pc) == null ? void 0 : u.connectionState) === "connected" && this.setStatus("connected") },await this.pc.setRemoteDescription(e),this.answer = await this.pc.createAnswer(),await this.pc.setLocalDescription(this.answer) } async stop() { this.pc && (this.pc.close(),this.pc = null),this.audioContext.state === "running" && await this.audioContext.suspend(),this.microphone.stop(),this.audioAnalyser = new Promise(e => { this.audioAnalyserDeffer = {resolve: e} }),this.muteInterval && clearInterval(this.muteInterval),this.statsInterval && clearInterval(this.statsInterval) }setStatus(e) { this.status = e,this.emit("status",e) }checkForMute(e) { const t = new Uint8Array(e.fftSize); e.getByteTimeDomainData(t); const s = t.reduce((i,n) => i + Math.abs(n - 128),0) / t.length; s < 0.05 && !this.peerMuted && (this.peerMuted = !0,this.emit("muted",this.peerMuted)),s >= 0.05 && this.peerMuted && (this.peerMuted = !1,this.emit("muted",this.peerMuted)) } async getStats(e) { const t = await e.getStats(); for (const s of t.values()) { if (s.type === "inbound-rtp" && s.kind === "audio") { const i = s; i.bytesReceived && (this.stats.rx.total_bytes += i.bytesReceived),i.packetsLost && (this.stats.rx.loss = i.packetsLost),i.packetsReceived && (this.stats.rx.total = i.packetsReceived) }s.type === "outbound-rtp" && s.kind === "audio" && s.bytesSent && this.stats.tx.total_bytes,s.type === "remote-inbound-rtp" && s.kind === "audio" && (s.packetsLost && (this.stats.tx.loss = s.packetsLost),s.packetsReceived && (this.stats.tx.total = s.packetsReceived),s.roundTripTime && s.roundTripTimeMeasurements && (this.stats.rtt.avg += (s.roundTripTime - this.stats.rtt.avg) / s.roundTripTimeMeasurements,(this.stats.rtt.min === 0 || this.stats.rtt.min > s.roundTripTime) && (this.stats.rtt.min = s.roundTripTime),this.stats.rtt.max < s.roundTripTime && (this.stats.rtt.max = s.roundTripTime))) } this.emit("stats",this.stats) }} function w(r,a,e,t) { const {callbacks: s,...i} = r; return r.callbacks.onEnd = () => { t.stop() },t instanceof y && (t.on("stats",n => { var o,c; return (c = (o = r.callbacks).onStats) == null ? void 0 : c.call(o,n) }),t.answer && (a.sendSdpAnswer(t.answer),t.on("muted",n => { var o,c,u,d; n ? (c = (o = r.callbacks).onPeerMute) == null || c.call(o) : (d = (u = r.callbacks).onPeerUnmute) == null || d.call(u) }))),{...i,connection_status: t.status,audio_analyser: t.audioAnalyser,async end() { var o,c; const {err: n} = await a.endCall(); return n || ((c = (o = r.callbacks).onEnd) == null || c.call(o),t.removeAllListeners("status")),{err: n} },async mute() { const {err: n} = await a.mute(); if (n) return {err: n}; r.muted = !0; const o = e.microphone.deviceUsed; if (o != null && o.stream) for (const c of o.stream.getTracks())c.enabled = !1; return {err: null} },async unmute() { const {err: n} = await a.unMute(); if (n) return {err: n}; r.muted = !1; const o = e.microphone.deviceUsed; if (o != null && o.stream) for (const c of o.stream.getTracks())c.enabled = !0; return {err: null} },onError(n) { r.callbacks.onError = n },onPeerMute(n) { r.callbacks.onPeerMute = n },onPeerUnmute(n) { r.callbacks.onPeerUnmute = n },onEnd(n) { r.callbacks.onEnd = () => { t.stop(),n() } },onStats(n) { r.callbacks.onStats = n },onConnectionStatus(n) { t.removeAllListeners("status"),t.on("status",(...o) => { n(...o) }),n(t.status) },onStatus(n) { r.callbacks.onStatus = n }} } function Z(r,a,e) { const {callbacks: t,...s} = r; return {...s,async accept() { const {err: i} = await e.canCall(); if (i) return {call: null,err: i.toString()}; const {transport: n,err: o} = await a.acceptCall({call_id: r.id}); if (!n) return {call: null,err: o}; const c = await e.startTransport(a.token,n).catch(() => null); return c ? {call: w(r,a,e,c),err: null} : (await a.endCall(),{call: null,err: "TransportError"}) },async reject() { var n,o,c,u; const {err: i} = await a.rejectCall(r.id); return i || ((o = (n = r.callbacks).onReject) == null || o.call(n),(u = (c = r.callbacks).onEnd) == null || u.call(c)),{err: i} },onAcceptedElsewhere(i) { r.callbacks.onAcceptedElsewhere = i },onRejectedElsewhere(i) { r.callbacks.onRejectedElsewhere = i },onUnanswered(i) { r.callbacks.onUnanswered = i },onEnd(i) { r.callbacks.onEnd = i },onStatus(i) { r.callbacks.onStatus = i }} } function M(r,a,e,t) { const {callbacks: s,...i} = r; function n() { return w(r,a,e,t) } function o() { t.stop() } return r.callbacks.onAccept = n,r.callbacks.onEnd = o,{...i,async end() { var u,d; const {err: c} = await a.endCall(); return c || (d = (u = r.callbacks).onEnd) == null || d.call(u),{err: c} },async mute() { const {err: c} = await a.mute(); if (c) return {err: c}; r.muted = !0; const u = e.microphone.deviceUsed; if (u != null && u.stream) for (const d of u.stream.getTracks())d.enabled = !1; return {err: null} },async unmute() { const {err: c} = await a.unMute(); if (c) return {err: c}; r.muted = !1; const u = e.microphone.deviceUsed; if (u != null && u.stream) for (const d of u.stream.getTracks())d.enabled = !0; return {err: null} },onStatus(c) { r.callbacks.onStatus = c },onPeerAccept(c) { r.callbacks.onAccept = () => c(n()) },onPeerReject(c) { r.callbacks.onReject = c },onUnanswered(c) { r.callbacks.onUnanswered = c },onEnd(c) { r.callbacks.onEnd = () => { o(),c() } }} } class W {constructor(a) { l(this,"calls"); this.multimedia = a,this.calls = new Map() }buildOffer(a,e) { const t = {id: a.id,type: a.type,device_token: e.token,direction: "INCOMING",status: "RINGING",muted: !1,peer: {...a.peer,muted: !1},callbacks: {}}; return this.calls.set(t.id,t),Z(t,e,this.multimedia) } async buildOutgoing(a,e) { const t = await this.multimedia.startTransport(e.token,a.transport),s = {id: a.id,type: a.type,device_token: e.token,peer: {...a.peer,muted: !1},direction: "OUTGOING",status: "RINGING",muted: !1,callbacks: {}}; return this.calls.set(s.id,s),M(s,e,this.multimedia,t) }bindDeviceEvents(a) { a.socket.on("call:status",(e,t) => { var i,n,o,c,u,d,v,x,_,S,N,E,T,R; const s = this.calls.get(e); s && (s.status = t,(n = (i = s.callbacks).onStatus) == null || n.call(i,t),t === "ACTIVE" && ((c = (o = s.callbacks).onAccept) == null || c.call(o)),t === "NOT_ANSWERED" && ((d = (u = s.callbacks).onUnanswered) == null || d.call(u),(x = (v = s.callbacks).onEnd) == null || x.call(v),this.calls.delete(s.id)),t === "REJECTED" && ((S = (_ = s.callbacks).onReject) == null || S.call(_),(E = (N = s.callbacks).onEnd) == null || E.call(N),this.calls.delete(s.id)),t === "ENDED" && ((R = (T = s.callbacks).onEnd) == null || R.call(T),this.calls.delete(s.id))) }),a.socket.on("peer:mute",(e,t) => { var i,n,o,c; const s = this.calls.get(e); s && (s.peer.muted = t,t ? (n = (i = s.callbacks).onPeerMute) == null || n.call(i) : (c = (o = s.callbacks).onPeerUnmute) == null || c.call(o)) }),a.socket.on("peer:accepted_elsewhere",e => { var s,i,n,o; const t = this.calls.get(e); t && ((i = (s = t.callbacks).onAcceptedElsewhere) == null || i.call(s),(o = (n = t.callbacks).onEnd) == null || o.call(n),this.calls.delete(e)) }),a.socket.on("peer:rejected_elsewhere",e => { var s,i,n,o; const t = this.calls.get(e); t && ((i = (s = t.callbacks).onAcceptedElsewhere) == null || i.call(s),(o = (n = t.callbacks).onEnd) == null || o.call(n),this.calls.delete(e)) }),a.socket.on("call:stats",(e,t) => { var n,o; const s = this.calls.get(e); if (!s) return; const i = {rtt: {avg: t.rtt.client.avg + t.rtt.whatsapp.avg,min: t.rtt.client.min + t.rtt.whatsapp.min,max: t.rtt.client.max + t.rtt.whatsapp.max},rx: t.rx,tx: t.tx}; (o = (n = s.callbacks).onStats) == null || o.call(n,i) }),a.socket.on("call:error",(e,t) => { var i,n,o,c; const s = this.calls.get(e); s && (s.status = "FAILED",(n = (i = s.callbacks).onError) == null || n.call(i,t),(c = (o = s.callbacks).onEnd) == null || c.call(o),this.calls.delete(s.id)) }),a.socket.on("disconnect",() => { var e,t,s,i; if (a.socket.active) for (const n of this.calls.values())(t = (e = n.callbacks).onStatus) == null || t.call(e,"DISCONNECTED"),(i = (s = n.callbacks).onEnd) == null || i.call(s),this.calls.delete(n.id) }) }} function g(r,a) { return {token: r.token,status: r.status,qrcode: r.qrcode,contact: r.contact,onStatus: e => { r.removeAllListeners("status"),r.on("status",e) },onQRCode: e => { r.removeAllListeners("qrcode"),r.on("qrcode",e) },onContact: e => { r.removeAllListeners("contact"),r.on("contact",e) },wakeUp: r.getInfos,restart: r.restart,logout: r.logout,pairingCode: r.requestPairingCode,delete: () => a.removeDevices([r.token])} } class C extends p {constructor(e) { super(); l(this,"socket"); l(this,"token"); l(this,"qrcode",null); l(this,"status","disconnected"); l(this,"contact",{official: null,unofficial: null}); l(this,"api"); this.token = e,this.api = m.create({baseURL: `https://devices.wavoip.com/${this.token}`}),this.socket = f.io("https://devices.wavoip.com",{transports: ["websocket"],path: `/${e}/websocket`,autoConnect: !1,auth: {upgrade: "true",version: "official"}}),this.socket.on("device:qrcode",t => { this.qrcode = t,this.emit("qrcode",t) }),this.socket.on("device:status",t => { this.status = t,this.emit("status",t) }),this.socket.on("device:contact",(t,s) => { this.contact[t] = s,this.emit("contact",t,s) }),this.socket.on("disconnect",() => { this.socket.active || (this.status = "disconnected",this.emit("status",this.status),this.getInfos().then(t => { t && (this.status = t.status,this.emit("status",this.status)) })) }),this.getInfos().then(t => { if (!t) { this.status = "error",this.emit("status",this.status); return } this.status = t.status,this.emit("status",this.status),this.socket.connect() }) }canCall() { return this.status ? this.status === "error" ? {err: "Erro no dispositivo"} : this.status === "connecting" ? {err: "É preciso vincular um número ao dispositivo"} : this.status === "restarting" ? {err: "Dispositivo está sendo reiniciado"} : {err: null} : {err: "Dispositivo não está pronto para ligar"} }startCall(e) { return new Promise(t => { this.socket.emit("call:start",e,s => { if (s.type === "error") return t({call: null,err: s.result}); t({call: {id: s.result.id,peer: s.result.peer,transport: s.result.transport},err: null}) }) }) }endCall() { return new Promise(e => { this.socket.emit("call:end",t => { t.type === "success" ? e({err: null}) : e({err: t.result}) }) }) }acceptCall(e) { return new Promise(t => { this.socket.emit("call:accept",{id: e.call_id},s => { if (s.type === "error") { t({transport: null,err: s.result}); return }t({transport: s.result,err: null}) }) }) }sendSdpAnswer(e) { this.socket.emit("call:sdp-answer",e) }rejectCall(e) { return new Promise(t => { this.socket.emit("call:reject",e,s => { s.type === "success" ? t({err: null}) : t({err: s.result}) }) }) }mute() { return new Promise(e => { this.socket.emit("call:mute",t => { t.type === "success" ? e({err: null}) : e({err: t.result}) }) }) }unMute() { return new Promise(e => { this.socket.emit("call:unmute",t => { t.type === "success" ? e({err: null}) : e({err: t.result}) }) }) }requestPairingCode(e) { return new Promise(t => { this.socket.emit("whatsapp:pairing_code",e,s => { if (s.type === "error") return t({pairingCode: null,err: s.result}); t({pairingCode: s.result,err: null}) }) }) } async getInfos() { return this.api.get("/whatsapp/all_info").then(e => e.data.result).catch(() => null) } async restart() { return this.api.get("/device/restart").then(e => e.data.result).catch(() => null) } async logout() { return this.api.get("/whatsapp/logout").then(e => e.data.result).catch(() => null) }} class k {constructor(a,e) { this.source = a,this.exception = e }toString() { return this.source === "audio" && this.exception.name === "NotAllowedError" ? "Permissão do alto falante foi negada" : this.exception.name === "NotAllowedError" ? "Permissão do microfone foi negada" : this.exception.name === "OverconstrainedError" ? "Microfone não suporta os requisitos de áudio" : this.exception.name === "SecurityError" ? "Não é possível acessar o microfone, a página é insegura" : this.exception.name === "NotReadableError" ? "Não foi possível acessar o microfone" : this.exception.name === "NotFoundError" ? "Nenhum microfone encontrado" : this.exception.name === "AbortError" ? "O hardware do microfone não pode ser inicializado" : "Algo falhou" }} class I extends p {constructor() { super(); l(this,"deviceUsed",null); l(this,"devices",[]); navigator.mediaDevices.addEventListener("devicechange",() => this.updateDeviceList()),this.updateDeviceList() } async requestMicPermission() { return navigator.mediaDevices.getUserMedia({audio: !0}) } async updateDeviceList() { await navigator.mediaDevices.enumerateDevices().then(t => t.map(s => ({type: "audio-in",label: s.label || "Unnamed Microphone",deviceId: s.deviceId}))); const e = await navigator.mediaDevices.enumerateDevices().then(t => t.filter(s => s.kind === "audioinput").map(s => ({type: "audio-in",label: s.label || "Unnamed Microphone",deviceId: s.deviceId}))); return this.devices = e,this.emit("devices",this.devices),e } async start() { var e; return this.devices.length ? this.selectDevice((e = this.deviceUsed) == null ? void 0 : e.deviceId) : {device: null,err: new k("microphone",new DOMException("","NotFoundError"))} } async selectDevice(e) { const {stream: t,err: s} = await navigator.mediaDevices.getUserMedia({audio: !0}).then(n => ({stream: n,err: null})).catch(n => ({stream: null,err: n})); if (!t) return {device: null,err: new k("microphone",s)}; const i = this.devices.find(n => n.deviceId === e); return this.deviceUsed = {...i,stream: t},{device: this.deviceUsed,err: null} }stop() { var e; if ((e = this.deviceUsed) != null && e.stream) { for (const t of this.deviceUsed.stream.getTracks())t.stop(); this.deviceUsed.stream = void 0 } }} class D extends p {constructor() { super(); l(this,"deviceUsed",null); l(this,"devices",[]); navigator.mediaDevices.addEventListener("devicechange",() => this.updateDeviceList()),this.updateDeviceList() } async updateDeviceList() { const e = await navigator.mediaDevices.enumerateDevices().then(t => t.filter(s => s.kind === "audiooutput").map(s => ({type: "audio-out",label: s.label || "Unnamed Speaker",deviceId: s.deviceId}))); return this.devices = e,this.emit("devices",this.devices),e } async start() { const {stream: e,err: t} = await navigator.mediaDevices.getUserMedia({audio: !0}).then(i => ({stream: i,err: null})).catch(i => ({stream: null,err: i})); if (!e) return {device: null,err: new k("audio",t)}; const s = this.devices.find(i => i.deviceId === ""); return this.deviceUsed = {...s,stream: e},{device: this.deviceUsed,err: null} }} class G extends p {constructor(e) { super(); l(this,"source"); l(this,"resample_node"); l(this,"ready"); this.audio_context = e,this.source = null,this.resample_node = null,this.ready = new Promise(t => { this.audio_context.audioWorklet.addModule("https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.min.js").then(() => this.audio_context.audioWorklet.addModule(new URL("data:text/javascript;base64,KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIGEgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7c3JjPW51bGw7YWNjdW11bGF0ZWRfUENNPVtdO2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO2NvbnN0IG49MSxzPWUucHJvY2Vzc29yT3B0aW9ucz8uc2FtcGxlUmF0ZXx8NDhlMyx0PTE2ZTMse2NyZWF0ZTpjLENvbnZlcnRlclR5cGU6cn09Z2xvYmFsVGhpcy5MaWJTYW1wbGVSYXRlO2MobixzLHQse2NvbnZlcnRlclR5cGU6ci5TUkNfU0lOQ19CRVNUX1FVQUxJVFl9KS50aGVuKGw9Pnt0aGlzLnNyYz1sfSl9cHJvY2VzcyhlLG4scyl7aWYoIWUubGVuZ3RofHwhZVswXS5sZW5ndGh8fCFlWzBdWzBdKXJldHVybiEwO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCBjPWVbdF07Zm9yKGxldCByPTA7cjxjLmxlbmd0aDtyKyspe2NvbnN0IGw9Y1tyXTtmb3IobGV0IG89MDtvPGwubGVuZ3RoO28rKyluW3RdW3JdW29dPWxbb119fWlmKHRoaXMuc3JjIT09bnVsbCl7Y29uc3QgdD10aGlzLnNyYy5mdWxsKGVbMF1bMF0sbnVsbCxudWxsKSxjPXRoaXMuY29udmVydFRvUENNKHQpO2Zvcih0aGlzLmFjY3VtdWxhdGVkX1BDTS5wdXNoKC4uLmMpO3RoaXMuYWNjdW11bGF0ZWRfUENNLmxlbmd0aD49MzIwOyl7Y29uc3Qgcj10aGlzLmFjY3VtdWxhdGVkX1BDTS5zcGxpY2UoMCwzMjApO3RoaXMucG9ydC5wb3N0TWVzc2FnZShuZXcgSW50MTZBcnJheShyKS5idWZmZXIpfX1yZXR1cm4hMH1jb252ZXJ0VG9QQ00oZSl7Y29uc3Qgbj1uZXcgSW50MTZBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBzPTA7czxlLmxlbmd0aDtzKyspbltzXT1NYXRoLm1heCgtMzI3NjgsTWF0aC5taW4oMzI3NjcsTWF0aC5mbG9vcihlW3NdKjMyNzY3KSkpO3JldHVybiBufX1yZWdpc3RlclByb2Nlc3NvcigicmVzYW1wbGUtcHJvY2Vzc29yIixhKX0pKCk7Cg==",typeof document > "u" && typeof location > "u" ? require("url").pathToFileURL(__filename).href : typeof document > "u" ? location.href : b && b.tagName.toUpperCase() === "SCRIPT" && b.src || new URL("index.umd.js",document.baseURI).href)).then(() => { t() })) }) } async start(e) { this.audio_context.state !== "running" && await this.audio_context.resume(),this.resample_node = new AudioWorkletNode(this.audio_context,"resample-processor",{processorOptions: {sampleRate: this.audio_context.sampleRate}}),this.resample_node.port.onmessage = t => this.emit("audio-data",t.data),this.source = this.audio_context.createMediaStreamSource(e),this.source.connect(this.resample_node) } async stop() { this.resample_node && (this.source && this.source.disconnect(this.resample_node),this.resample_node.port.onmessage = null,this.resample_node.disconnect()),this.resample_node = null,this.source = null,this.removeAllListeners("audio-data") }} class U {constructor(a) { l(this,"playback_node"); l(this,"analyser_node"); l(this,"ready"); this.audio_context = a,this.analyser_node = null,this.playback_node = null,this.ready = new Promise(e => { this.audio_context.audioWorklet.addModule(new URL("data:text/javascript;base64,KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIG8gZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3J7dWludDg9bmV3IFVpbnQ4QXJyYXkoMCk7b2Zmc2V0PTA7Y29uc3RydWN0b3Iocyl7c3VwZXIocyksdGhpcy5wb3J0Lm9ubWVzc2FnZT10aGlzLmFwcGVuZEJ1ZmZlcnMuYmluZCh0aGlzKX1hc3luYyBhcHBlbmRCdWZmZXJzKHtkYXRhOntidWZmZXI6c319KXtjb25zdCBlPW5ldyBVaW50OEFycmF5KHRoaXMudWludDgubGVuZ3RoK3MubGVuZ3RoKTtyZXR1cm4gZS5zZXQodGhpcy51aW50OCwwKSxlLnNldChzLHRoaXMudWludDgubGVuZ3RoKSx0aGlzLnVpbnQ4PWUsITB9cHJvY2VzcyhzLGUsYSl7Y29uc3QgdT1lWzBdO2lmKHRoaXMub2Zmc2V0Pj10aGlzLnVpbnQ4Lmxlbmd0aClyZXR1cm4hMDtjb25zdCBpPW5ldyBVaW50OEFycmF5KDI1Nik7Zm9yKGxldCB0PTA7dDwyNTYmJiEodGhpcy5vZmZzZXQ+PXRoaXMudWludDgubGVuZ3RoKTt0KyssdGhpcy5vZmZzZXQrKylpW3RdPXRoaXMudWludDhbdGhpcy5vZmZzZXRdO2NvbnN0IHI9bmV3IFVpbnQxNkFycmF5KGkuYnVmZmVyKTtmb3IobGV0IHQ9MDt0PHIubGVuZ3RoO3QrKyl7Y29uc3Qgbj1yW3RdLGY9bj49MzI3Njg/LSg2NTUzNi1uKS8zMjc2ODpuLzMyNzY3O3VbMF1bdF09Zn1yZXR1cm4gdGhpcy51aW50OC5sZW5ndGgtdGhpcy5vZmZzZXQ+MjVlMyYmKHRoaXMub2Zmc2V0Kz0xZTQpLCEwfX1yZWdpc3RlclByb2Nlc3NvcigiYXVkaW8tZGF0YS13b3JrbGV0LXN0cmVhbSIsbyl9KSgpOwo=",typeof document > "u" && typeof location > "u" ? require("url").pathToFileURL(__filename).href : typeof document > "u" ? location.href : b && b.tagName.toUpperCase() === "SCRIPT" && b.src || new URL("index.umd.js",document.baseURI).href)).then(() => e()) }) } async start() { this.audio_context.state !== "running" && await this.audio_context.resume(),this.playback_node = new AudioWorkletNode(this.audio_context,"audio-data-worklet-stream",{numberOfInputs: 1,numberOfOutputs: 1,channelCount: 1,processorOptions: {offset: 0}}),this.playback_node.connect(this.audio_context.destination) }createAnalyserNode() { var e; const a = this.audio_context.createAnalyser(); return (e = this.playback_node) == null || e.connect(a),a.fftSize = 256,this.analyser_node = a,a }sendAudioData(a) { var e; (e = this.playback_node) == null || e.port.postMessage({buffer: new Uint8Array(a)}) } async stop() { var a,e,t; (a = this.playback_node) == null || a.port.postMessage({type: "clear",buffer: []}),(e = this.playback_node) == null || e.disconnect(),this.playback_node = null,(t = this.analyser_node) == null || t.disconnect(),this.analyser_node = null }} class z extends p {constructor(e) { super(); l(this,"SOCKET_RECONNECT_CODES",[1001,1006,1011,1015]); l(this,"socket",null); l(this,"in"); l(this,"out"); l(this,"audioAnalyser"); l(this,"status","connecting"); this.microphone = e,this.in = new G(new AudioContext({latencyHint: 0})),this.out = new U(new AudioContext({sampleRate: 16e3,latencyHint: 0})),this.audioAnalyser = Promise.resolve({}) } async start(e,t) { var s; (s = this.microphone.deviceUsed) != null && s.stream && (await this.in.ready,await this.in.start(this.microphone.deviceUsed.stream),await this.out.ready,await this.out.start(),this.audioAnalyser = Promise.resolve(this.out.createAnalyserNode()),this.socket = this.connect(e,t),this.in.on("audio-data",i => { var n; ((n = this.socket) == null ? void 0 : n.readyState) === WebSocket.OPEN && this.socket.send(i) }),this.socket.addEventListener("message",i => { var n; if (new Uint8Array(i.data).length === 4) { (n = this.socket) == null || n.send("pong"); return } this.out.sendAudioData(i.data) })) } async stop() { var e; (e = this.socket) == null || e.close(),this.socket = null,this.microphone.stop(),await this.in.stop(),await this.out.stop() }connect(e,t) { const {server: s} = e,i = `wss://${s.host}:${s.port}?token=${t}`,n = new WebSocket(i); return n.binaryType = "arraybuffer",this.status = "connecting",this.emit("status",this.status),this.bindListeners(n,e,t),n }bindListeners(e,t,s) { e.addEventListener("open",() => { this.status = "connected",this.emit("status",this.status) }),e.addEventListener("error",() => { this.status = "disconnected",this.emit("status",this.status) }),e.addEventListener("close",i => { this.status = "disconnected",this.emit("status",this.status),this.SOCKET_RECONNECT_CODES.includes(i.code) && setTimeout(() => { this.socket = this.connect(t,s) },1e3) }) }} class A {constructor() { l(this,"webRTC",null); l(this,"websocket",null); l(this,"speaker",new D()); l(this,"microphone",new I()) } async canCall() { const {device: a,err: e} = await this.microphone.start(); if (!a) return {err: e}; const {device: t,err: s} = await this.speaker.start(); return t ? {err: null} : {err: s} } async startTransport(a,e) { return e.type === "official" ? (this.webRTC || (this.webRTC = new y(this.microphone)),await this.webRTC.start(e.sdpOffer),this.webRTC) : (this.websocket || (this.websocket = new z(this.microphone)),await this.websocket.start(e,a),this.websocket) }} class L extends p {constructor(e) { super(); l(this,"call_manager"); l(this,"_devices"); l(this,"_multimedia"); this._devices = [...new Set(e.tokens)].map(t => new C(t)),this._multimedia = new A(),this.call_manager = new W(this._multimedia); for (const t of this._devices) this.bindDeviceEvents(t) }onOffer(e) { this.removeAllListeners("offer"),this.on("offer",e) } get multimedia() { return {microphone: this._multimedia.microphone,speaker: this._multimedia.speaker} }getMultimediaDevices() { const e = this.multimedia.microphone.devices,t = this.multimedia.speaker.devices; return {microphones: e,speakers: t} } async startCall(e) { var n; const {err: t} = await this._multimedia.canCall(); if (t) return {call: null,err: {message: t.toString(),devices: []}}; const s = (n = e.fromTokens) != null && n.length ? e.fromTokens.map(o => this._devices.find(c => c.token === o)).filter(o => !!o) : this._devices; if (!s.length) return {call: null,err: {devices: [],message: "Não existe nenhum dispositivo"}}; const i = []; for (const o of s) { const c = o.canCall(); if (c.err) { i.push({token: o.token,reason: c.err}); continue } const {call: u,err: d} = await o.startCall(e.to); if (!u) { i.push({token: o.token,reason: d}); continue } return {call: await this.call_manager.buildOutgoing({...u,type: "unofficial"},o),err: null} } return {call: null,err: {message: "Não foi possível realizar a chamada",devices: i}} } async*startCallIterator(e) { var i; const {err: t} = await this._multimedia.canCall(); if (t) return {call: null,err: t.toString()}; const s = (i = e.fromTokens) != null && i.length ? e.fromTokens.map(n => this._devices.find(o => o.token === n)).filter(n => !!n) : this._devices; if (!s.length) return {call: null,err: "Nenhum dispositivo configurado"}; for (const n of s) { const o = n.canCall(); if (o.err) { yield {call: null,token: n.token,err: o.err}; continue } const {call: c,err: u} = await n.startCall(e.to); if (!c) { yield {call: null,token: n.token,err: u}; continue } return {call: await this.call_manager.buildOutgoing({...c,type: "unofficial"},n),token: n.token} } return {call: null,err: "Não foi possível realizar a chamada"} } get devices() { return this._devices.map(e => g(e,this)) }getDevices() { return this.devices }addDevices(e = []) { const t = []; for (const s of e) { if (this.devices.find(n => e.includes(n.token))) continue; const i = new C(s); this._devices.push(i),t.push(i),this.bindDeviceEvents(i) } return t.map(s => g(s,this)) }removeDevices(e) { if (!e.length) return this.devices; const t = []; for (const s of this._devices) { if (e.includes(s.token)) { s.socket.close(); continue }t.push(s) } return this._devices = t,this.devices } async*wakeUpDevicesIterator(e = []) { const t = e.length ? this._devices.filter(s => e.includes(s.token)) : this._devices; for (const s of t) { const i = await s.getInfos(); yield {token: s.token,waken: !!i} } }wakeUpDevices(e = []) { return (e.length ? this._devices.filter(s => e.includes(s.token)) : this._devices).map(s => s.getInfos().then(i => ({token: s.token,waken: !!i}))) }bindDeviceEvents(e) { e.socket.on("call:offer",t => { const s = this.call_manager.buildOffer(t,e); this.emit("offer",s) }),this.call_manager.bindDeviceEvents(e) }}h.Wavoip = L,Object.defineProperty(h,Symbol.toStringTag,{value: "Module"}) });
